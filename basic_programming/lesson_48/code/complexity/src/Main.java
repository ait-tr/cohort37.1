public class Main {
    /*
     ВВедение в анализ сложности алгоритмов.

     Алгоритм - это последовательность шагов, представляющая собой исключительно вычисление и не учитывающая особенности
     реализации "компьютерного железа", на котором она работает
     Анализ сложности дает возможность узнать как быстро будет работать программа когда она совершает вычисления
     на разных обьемах входных данных.
     */

    public int findMaxElt( int[]ints, int n){
        int max = ints[0];// 2 действия

        // 2 действия до запуска цикла - присвоение начального значения и проверка условия окончания цикла
        for( int i = 0; i < n; i++){
            if(ints[i] > max){
                max = ints[i];
            }
        }
        return max;
    }

    // f(n) = 4 + 2n - необходимое алгоритму кол-во инструкций для цикла for  с пустым  телом
    // 1,2,3,4
    // 4,3,2,1
    // В теории алгоритмов рассматриваются наихудшие сценарии, т.е. у нас это массив, упорядоченный по возрастанию и
    // макс.значение переписываеися для каждой итерации
    // f(n) = 4 + 2n +4n = 4 +6n

    // когда n  сильно вырастает, константу можно не учитывать, они не важны и отбрасываются
    // f(n) = 6n
    // f(n) = n;

    /*
    f(n) ´= 9n +24 ->   f(n) = n
    f(n) = 234*1  ->    f(n) = 1
    f(n) = n^2 + 3n +368  -> f(n) =  n^2
    f(n) = n^3 + 2000n + 300 -> f(n)= n^3

    Big O

    O(1) - алгоритм с константным временем и его сложность равна 1
    O(n) - сложность алгоритма О(n)
    O(n^2) - сложность алгоритма n ^2
    O( log n) -  логарифмическая сложность

    2^x = 1024
    2^10 = 1024
    логарифм 1024 - это та степень, в которую нужно возвести 2 чтобы получить 1024
    log(1024) = 10

    log(64) = 6
    2^6 = 64

    2^x = 4


    0   n
    1  n/2 2^1
    2  n/4  2^2
    3  n/8  2^3
    i  n/2^i
     */
}
